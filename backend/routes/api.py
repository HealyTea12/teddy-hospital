import base64
import os
from typing import Annotated

import qrcode
import reportlab.pdfgen.canvas
from anyio import SpooledTemporaryFile
from fastapi import APIRouter, File, Form, Header, Query, Response, UploadFile
from fastapi.responses import FileResponse, JSONResponse

from backend.routes.jobqueue import Job, JobQueue

from ..config import config

router = APIRouter()
job_queue = JobQueue(config.results_per_image, config.carrousel_size, config.storage[0])


@router.get(
    "/qr",
    responses={200: {"content": {"application/pdf": {}}}},
    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=Response,
)
def gen_qr_codes(n: int = Query(ge=0, le=1000)):
    qrs = []
    for i in range(n):
        url = config.storage[0].create_storage_for_user()
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        qr.add_data(f"{url}")
        qr.make(fit=True)
        img = qr.make_image(fill_color="black", back_color="white")
        qrs.append(img)
        qr.clear()

    gen_qr_pdf(qrs)
    if n > 0:
        return FileResponse(
            path="qr.pdf",
            media_type="application/pdf",
            filename="qr.pdf",
        )
    else:
        return Response(content="No QR codes generated", media_type="text/plain")


def gen_qr_pdf(qrs: list, size: int = 100):
    """
    qrs: list qrcode images
    """
    X_BORDER, Y_BORDER, X_SPACING, Y_SPACING = 30, 30, 10, 10
    c = reportlab.pdfgen.canvas.Canvas("qr.pdf")
    c.drawCentredString(
        300,
        820,
        "Each of the following QR Codes contains a link to an individual storage location",
    )
    c.drawCentredString(
        300, 800, "where the users can view and download their X-Ray results."
    )
    # Draw grid
    for i in [25, 135, 245, 355, 465, 575]:
        c.line(i, 25, i, 795)
    for i in [25, 135, 245, 355, 465, 575, 685, 795]:
        c.line(25, i, 575, i)

    x, y = X_BORDER, Y_BORDER
    for i, img in enumerate(qrs):
        # TODO: this is a hack solution, should draw image from memory and not have to save into file
        os.makedirs("temp", exist_ok=True)
        img.save(f"temp/temp_{i}.png")
        c.drawImage(f"temp/temp_{i}.png", x, y, width=size, height=size)
        x += size + X_SPACING
        if x > 500:
            x = X_BORDER
            y += size + Y_SPACING
            if y >= 800:
                c.showPage()
                x, y = X_BORDER, Y_BORDER
    c.save()


from fastapi import UploadFile


@router.post(
    "/upload/",
    responses={200: {"content": {"application/json": {}}}},
)
async def create_upload_file(
    file: UploadFile = File(...),
    first_name: str = Form(...),
    last_name: str = Form(...),
    animal_name: str = Form(...),
    qr_content: str = Form(...),
):
    """Receive image of a teddy and user id so that we know where to save later.
    the image itself also gets an id so it can be referenced later when receiving results
    from AI."""
    f = SpooledTemporaryFile()
    await f.write(file.file.read())
    job = Job(
        file=f,
        owner_ref=qr_content,
        first_name=first_name,
        last_name=last_name,
        animal_name=animal_name,
    )
    job_queue.add_job(job)
    return {"status": "success", "job_id": job.id, "current_jobs": len(job_queue.queue)}


@router.get(
    "/job",
    responses={200: {"content": {"image/png": {}}}},
    response_class=Response,
)
async def get_job():
    """
    Get job from the queue. Returns an image with an id.
    """
    job = job_queue.get_job()
    if job is None:
        return Response(content="No Jobs in queue", media_type="text/plain")
    await job.file.seek(0)
    response = Response(content=await job.file.read())
    response.headers["Content-Type"] = "image/png"
    response.headers["img_id"] = str(job.id)
    response.headers["first_name"] = job.first_name
    response.headers["last_name"] = job.last_name
    response.headers["animal_name"] = job.animal_name
    return response


@router.post("/job", responses={200: {"content": {"application/json": {}}}})
async def conclude_job(
    image_id: Annotated[int, Header()], result: Annotated[bytes, File()]
):
    f = SpooledTemporaryFile()
    await f.write(result)
    job_queue.submit_job(image_id, f)
    return {"status": "success"}


@router.get("/confirm")
async def confirm_job(
    image_id: Annotated[int, Query()],
    choice: Annotated[int, Query()],
    confirm: Annotated[bool, Query()],
):
    global current_results
    await job_queue.confirm_job(image_id, confirm, choice)
    current_results.pop(image_id, None)
    return JSONResponse(content={"status": "success"})


current_results: dict[int, list[SpooledTemporaryFile[bytes]]] = {}


@router.get("/results")
async def get_results() -> JSONResponse:
    # Compare job_queue.awaiting_approval with current_results
    global current_results
    diff: dict[int, list[SpooledTemporaryFile[bytes]]] = {}
    for job_id, (job, results) in job_queue.awaiting_approval.items():
        if job_id not in current_results:
            diff[job_id] = results
        else:
            new_results: list[SpooledTemporaryFile[bytes]] = []
            for i, result in enumerate(results):
                if result not in current_results[job_id]:
                    new_results.append(result)
            if new_results:
                diff[job_id] = new_results
    current_results = current_results | diff
    # Convert SpooledTemporaryFile to base64 encoded strings in response
    response = {"results": []}
    for job_id, results in diff.items():
        for r in results:
            await r.seek(0)
        response["results"].append(
            {
                "job_id": job_id,
                "results": [base64.b64encode(await r.read()).decode() for r in results],
            }
        )

    print(f"diff={diff}")
    print(f"current_results={current_results}")
    return JSONResponse(content=response)
