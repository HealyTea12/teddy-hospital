import base64
import http
import io
import os
import zipfile
from PIL import Image
from typing import Annotated, List, Tuple

import qrcode
import reportlab.pdfgen.canvas
from anyio import SpooledTemporaryFile
from fastapi import (
    APIRouter,
    BackgroundTasks,
    File,
    Form,
    Header,
    Query,
    Response,
    UploadFile,
)
from fastapi.responses import FileResponse, JSONResponse, StreamingResponse

from ..config import config
from .jobqueue import Job, JobQueue

router = APIRouter()
job_queue = JobQueue(config.results_per_image, config.carrousel_size, config.storage[0])

qr_generation_progress: float = 0.0


@router.get(
    "/qr",
    responses={200: {"content": {"application/pdf": {}}}},
    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=Response,
)
def gen_qr_codes(
    n: int = Query(gt=0, le=1000), background_tasks: BackgroundTasks = BackgroundTasks()
):
    global qr_generation_progress
    qr_generation_progress = 0.0
    background_tasks.add_task(get_qrs, n)
    return Response(
        content=f"Generating {n} QR codes, this may take a while. Check the progress at /qr/progress",
        media_type="text/plain",
    )


@router.get(
    "/qr/progress",
    response_class=JSONResponse,
)
def get_qr_progress():
    print(f"QR generation progress: {qr_generation_progress}%")
    return JSONResponse(
        content={
            "progress": qr_generation_progress,
        }
    )


@router.get("/qr/download", response_class=FileResponse)
def download_qr_pdf():
    return FileResponse(
        path="qr.pdf",
        media_type="application/pdf",
        filename="qr.pdf",
    )


def get_qrs(n):
    global qr_generation_progress
    qr_generation_progress = 0.0
    qrs = []
    for i in range(n):
        url = config.storage[0].create_storage_for_user()
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        qr.add_data(f"{url}")
        qr.make(fit=True)
        img = qr.make_image(fill_color="black", back_color="white")
        qrs.append(img)
        qr.clear()
        qr_generation_progress = i / n * 100
    gen_qr_pdf(qrs)


def gen_qr_pdf(qrs: list, size: int = 100):
    """
    qrs: list qrcode images
    """
    global qr_generation_progress
    qr_generation_progress = 0.0
    X_BORDER, Y_BORDER, X_SPACING, Y_SPACING = 30, 30, 10, 10
    c = reportlab.pdfgen.canvas.Canvas("qr.pdf")
    c.drawCentredString(
        300,
        820,
        "Each of the following QR Codes contains a link to an individual storage location",
    )
    c.drawCentredString(
        300, 800, "where the users can view and download their X-Ray results."
    )
    # Draw grid
    for i in [25, 135, 245, 355, 465, 575]:
        c.line(i, 25, i, 795)
    for i in [25, 135, 245, 355, 465, 575, 685, 795]:
        c.line(25, i, 575, i)

    x, y = X_BORDER, Y_BORDER
    for i, img in enumerate(qrs):
        # TODO: this is a hack solution, should draw image from memory and not have to save into file
        os.makedirs("temp", exist_ok=True)
        img.save(f"temp/temp_{i}.png")
        c.drawImage(f"temp/temp_{i}.png", x, y, width=size, height=size)
        x += size + X_SPACING
        if x > 500:
            x = X_BORDER
            y += size + Y_SPACING
            if y >= 800:
                c.showPage()
                x, y = X_BORDER, Y_BORDER
        qr_generation_progress = i / len(qrs) * 100
    c.save()
    qr_generation_progress = 100.0


@router.post(
    "/upload",
    responses={200: {"content": {"application/json": {}}}},
)
async def create_upload_file(
    file: UploadFile = File(...),
    first_name: str = Form(...),
    last_name: str = Form(...),
    animal_name: str = Form(...),
    qr_content: str = Form(...),
    animal_type: str = Form("other"),  # TODO: add validator
    broken_bone: bool = Form(False),
):
    """Receive image of a teddy and user id so that we know where to save later.
    the image itself also gets an id so it can be referenced later when receiving results
    from AI."""
    f = SpooledTemporaryFile()
    await f.write(file.file.read())
    job = Job(
        file=f,
        owner_ref=qr_content,
        first_name=first_name,
        last_name=last_name,
        animal_name=animal_name,
        animal_type=animal_type,
        broken_bone=broken_bone,
    )
    job_queue.add_job(job)
    return {"status": "success", "job_id": job.id, "current_jobs": len(job_queue.queue)}


@router.get(
    "/job",
    responses={
        200: {"content": {"image/png": {}}},
        204: {"description": "No Jobs in queue"},
    },
    response_class=Response,
)
async def get_job():
    """
    Get job from the queue. Returns an image with an id.
    """
    job = job_queue.get_job()
    if job is None:
        return Response(
            content="No Jobs in queue", media_type="text/plain", status_code=204
        )
    await job.file.seek(0)
    response = Response(content=await job.file.read())
    response.headers["Content-Type"] = "image/png"
    response.headers["img_id"] = str(job.id)
    response.headers["first_name"] = job.first_name
    response.headers["last_name"] = job.last_name
    response.headers["animal_name"] = job.animal_name
    response.headers["animal_type"] = job.animal_type
    response.headers["broken_bone"] = str(job.broken_bone).lower()
    return response


@router.post("/job", responses={200: {"content": {"application/json": {}}}})
async def conclude_job(
    image_id: Annotated[int, Form()], result: Annotated[UploadFile, File()]
):
    await job_queue.submit_job(image_id, await result.read())
    return {"status": "success"}


@router.get("/confirm")
async def confirm_job(
    image_id: Annotated[int, Query()],
    choice: Annotated[int, Query()],
    confirm: Annotated[bool, Query()],
):
    global current_results
    await job_queue.confirm_job(image_id, confirm, choice)
    current_results.pop(image_id, None)
    return JSONResponse(content={"status": "success"})


current_results: dict[int, list[SpooledTemporaryFile[bytes]]] = {}


@router.get("/results")
async def get_results() -> JSONResponse:
    # Compare job_queue.awaiting_approval with current_results
    global current_results
    diff: dict[int, list[SpooledTemporaryFile[bytes]]] = {}
    for job_id, (job, results) in job_queue.awaiting_approval.items():
        if job_id not in current_results:
            diff[job_id] = results
        else:
            new_results: list[SpooledTemporaryFile[bytes]] = []
            for i, result in enumerate(results):
                if result not in current_results[job_id]:
                    new_results.append(result)
            if new_results:
                diff[job_id] = new_results
    current_results = current_results | diff
    # Convert SpooledTemporaryFile to base64 encoded strings in response
    response = {"results": []}
    for job_id, results in diff.items():
        for r in results:
            await r.seek(0)
        response["results"].append(
            {
                "job_id": job_id,
                "results": [base64.b64encode(await r.read()).decode() for r in results],
            }
        )

    # print(f"diff={diff}")
    # print(f"current_results={current_results}")
    return JSONResponse(content=response)


@router.get("/animal_types", response_class=JSONResponse)
def get_animal_types():
    return JSONResponse({"types": config.animal_types})

class MockQueue:
    def __init__(self):
        self.carousel: list[Tuple[SpooledTemporaryFile, SpooledTemporaryFile]] = []

    async def async_init(self, sample_dir: str = "sample"):
        await self._populate_from_local(sample_dir)

    async def _populate_from_local(self, sample_dir: str):
        self.carousel.clear()
        if not os.path.isdir(sample_dir):
            raise FileNotFoundError(f"Sample directory '{sample_dir}' does not exist")

        image_files = [
            os.path.join(sample_dir, f)
            for f in sorted(os.listdir(sample_dir))
            if f.lower().endswith((".png", ".jpg", ".jpeg", ".gif", ".bmp"))
        ]

        for path in image_files:  
            print(path)
            with open(path, "rb") as img_file:
                data = img_file.read()
        
                f = SpooledTemporaryFile(mode="w+b")
                await f.write(data)
                await f.seek(0)

                with Image.open(io.BytesIO(data)) as img:
                    white_image = Image.new("RGB", img.size, (255, 255, 255))  # Create a white image
                    # Save the white image to a SpooledTemporaryFile
                    white_file = SpooledTemporaryFile(mode="w+b")
                    with io.BytesIO() as output:
                        white_image.save(output, format='PNG')  # Save as PNG or any desired format
                        await white_file.write(output.getvalue())
                        await white_file.seek(0)
                
                self.carousel.append((f, white_file))

    def get_carousel(self) -> list[SpooledTemporaryFile, SpooledTemporaryFile]:
        return self.carousel

mock_queue = MockQueue()


# route to get pictures for carousel
@router.get("/carousel", response_class=JSONResponse)
async def get_carousel_list():
    # Returns a list of URLs to fetch carousel images.
    await mock_queue.async_init("routes/sample")
    carousel_items = mock_queue.get_carousel()
    return JSONResponse(content=[f"http://localhost:8000/carousel/{i}" for i in range(len(carousel_items))])

# route to get individual pictures for displaying
@router.get("/carousel/{index}")
async def get_carousel_image(index: int):
    carousel = mock_queue.get_carousel()
    if index < 0 or index >= len(carousel):
        return Response(status_code=404)
    
    xray_file, original_file = carousel[index]
    await xray_file.seek(0)
    await original_file.seek(0)

    zip_buffer = io.BytesIO()
    with zipfile.ZipFile(zip_buffer, "w") as zip_file:
        zip_file.writestr("xray.png", await xray_file.read())
        zip_file.writestr("original.png", await original_file.read())
    zip_buffer.seek(0)

    headers = {
        "Content-Disposition": f"attachment; filename=carousel_{index}.zip"
    }

    return StreamingResponse(zip_buffer, media_type="application/zip", headers=headers)
