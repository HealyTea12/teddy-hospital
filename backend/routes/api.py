import base64
import http
import os
from typing import Annotated, List

import qrcode
import reportlab.pdfgen.canvas
from anyio import SpooledTemporaryFile
from fastapi import (
    APIRouter,
    BackgroundTasks,
    File,
    Form,
    Header,
    Query,
    Response,
    Request,
    UploadFile,
)
from fastapi.responses import FileResponse, JSONResponse, StreamingResponse
import requests

from ..config import config
from .jobqueue import Job, JobQueue

router = APIRouter()
job_queue = JobQueue(config.results_per_image, config.carrousel_size, config.storage[0])

qr_generation_progress: float = 0.0


@router.get(
    "/qr",
    responses={200: {"content": {"application/pdf": {}}}},
    # Prevent FastAPI from adding "application/json" as an additional
    # response media type in the autogenerated OpenAPI specification.
    # https://github.com/tiangolo/fastapi/issues/3258
    response_class=Response,
)
def gen_qr_codes(
    n: int = Query(gt=0, le=1000), background_tasks: BackgroundTasks = BackgroundTasks()
):
    global qr_generation_progress
    qr_generation_progress = 0.0
    background_tasks.add_task(get_qrs, n)
    return Response(
        content=f"Generating {n} QR codes, this may take a while. Check the progress at /qr/progress",
        media_type="text/plain",
    )


@router.get(
    "/qr/progress",
    response_class=JSONResponse,
)
def get_qr_progress():
    print(f"QR generation progress: {qr_generation_progress}%")
    return JSONResponse(
        content={
            "progress": qr_generation_progress,
        }
    )


@router.get("/qr/download", response_class=FileResponse)
def download_qr_pdf():
    return FileResponse(
        path="qr.pdf",
        media_type="application/pdf",
        filename="qr.pdf",
    )


def get_qrs(n):
    global qr_generation_progress
    qr_generation_progress = 0.0
    qrs = []
    for i in range(n):
        url = config.storage[0].create_storage_for_user()
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        qr.add_data(f"{url}")
        qr.make(fit=True)
        img = qr.make_image(fill_color="black", back_color="white")
        qrs.append(img)
        qr.clear()
        qr_generation_progress = i / n * 100
    gen_qr_pdf(qrs)


def gen_qr_pdf(qrs: list, size: int = 100):
    """
    qrs: list qrcode images
    """
    global qr_generation_progress
    qr_generation_progress = 0.0
    X_BORDER, Y_BORDER, X_SPACING, Y_SPACING = 30, 30, 10, 10
    c = reportlab.pdfgen.canvas.Canvas("qr.pdf")
    c.drawCentredString(
        300,
        820,
        "Each of the following QR Codes contains a link to an individual storage location",
    )
    c.drawCentredString(
        300, 800, "where the users can view and download their X-Ray results."
    )
    # Draw grid
    for i in [25, 135, 245, 355, 465, 575]:
        c.line(i, 25, i, 795)
    for i in [25, 135, 245, 355, 465, 575, 685, 795]:
        c.line(25, i, 575, i)

    x, y = X_BORDER, Y_BORDER
    for i, img in enumerate(qrs):
        # TODO: this is a hack solution, should draw image from memory and not have to save into file
        os.makedirs("temp", exist_ok=True)
        img.save(f"temp/temp_{i}.png")
        c.drawImage(f"temp/temp_{i}.png", x, y, width=size, height=size)
        x += size + X_SPACING
        if x > 500:
            x = X_BORDER
            y += size + Y_SPACING
            if y >= 800:
                c.showPage()
                x, y = X_BORDER, Y_BORDER
        qr_generation_progress = i / len(qrs) * 100
    c.save()
    qr_generation_progress = 100.0


@router.post(
    "/upload",
    responses={200: {"content": {"application/json": {}}}},
)
async def create_upload_file(
    file: UploadFile = File(...),
    first_name: str = Form(...),
    last_name: str = Form(...),
    animal_name: str = Form(...),
    qr_content: str = Form(...),
    animal_type: str = Form("other"),  # TODO: add validator
    broken_bone: bool = Form(False),
):
    """Receive image of a teddy and user id so that we know where to save later.
    the image itself also gets an id so it can be referenced later when receiving results
    from AI."""
    f = SpooledTemporaryFile()
    await f.write(file.file.read())
    job = Job(
        file=f,
        owner_ref=qr_content,
        first_name=first_name,
        last_name=last_name,
        animal_name=animal_name,
        animal_type=animal_type,
        broken_bone=broken_bone,
    )
    job_queue.add_job(job)
    return {"status": "success", "job_id": job.id, "current_jobs": len(job_queue.queue)}


@router.get(
    "/job",
    responses={
        200: {"content": {"image/png": {}}},
        204: {"description": "No Jobs in queue"},
    },
    response_class=Response,
)
async def get_job():
    """
    Get job from the queue. Returns an image with an id.
    """
    job = job_queue.get_job()
    if job is None:
        return Response(
            content="No Jobs in queue", media_type="text/plain", status_code=204
        )
    await job.file.seek(0)
    response = Response(content=await job.file.read())
    response.headers["Content-Type"] = "image/png"
    response.headers["img_id"] = str(job.id)
    response.headers["first_name"] = job.first_name
    response.headers["last_name"] = job.last_name
    response.headers["animal_name"] = job.animal_name
    response.headers["animal_type"] = job.animal_type
    response.headers["broken_bone"] = str(job.broken_bone).lower()
    return response


@router.post("/job", responses={200: {"content": {"application/json": {}}}})
async def conclude_job(
    image_id: Annotated[int, Form()], result: Annotated[UploadFile, File()]
):
    await job_queue.submit_job(image_id, await result.read())
    return {"status": "success"}


@router.get("/confirm")
async def confirm_job(
    image_id: Annotated[int, Query()],
    choice: Annotated[int, Query()],
    confirm: Annotated[bool, Query()],
):
    global current_results
    await job_queue.confirm_job(image_id, confirm, choice)
    current_results.pop(image_id, None)
    return JSONResponse(content={"status": "success"})


current_results: dict[int, list[SpooledTemporaryFile[bytes]]] = {}


@router.get("/results")
async def get_results() -> JSONResponse:
    # Compare job_queue.awaiting_approval with current_results
    global current_results
    diff: dict[int, list[SpooledTemporaryFile[bytes]]] = {}
    for job_id, (job, results) in job_queue.awaiting_approval.items():
        if job_id not in current_results:
            diff[job_id] = results
        else:
            new_results: list[SpooledTemporaryFile[bytes]] = []
            for i, result in enumerate(results):
                if result not in current_results[job_id]:
                    new_results.append(result)
            if new_results:
                diff[job_id] = new_results
    current_results = current_results | diff
    # Convert SpooledTemporaryFile to base64 encoded strings in response
    response = {"results": []}
    for job_id, results in diff.items():
        for r in results:
            await r.seek(0)
        response["results"].append(
            {
                "job_id": job_id,
                "results": [base64.b64encode(await r.read()).decode() for r in results],
            }
        )

    # print(f"diff={diff}")
    # print(f"current_results={current_results}")
    return JSONResponse(content=response)


@router.get("/animal_types", response_class=JSONResponse)
def get_animal_types():
    return JSONResponse({"types": config.animal_types})


# route to get pictures for carousel
@router.get("/carousel", response_class=JSONResponse)
async def get_carousel_list(request : Request):
    # Returns a list of URLs to fetch carousel images.
    carousel_items = job_queue.get_carousel()
    base_url = str(request.base_url)
    return JSONResponse(content=[f"{base_url}/carousel/{i}" for i in range(len(carousel_items))])

# route to get individual pictures for displaying
@router.get("/carousel/{index}", response_class=StreamingResponse)
async def get_carousel_image(index: int):
    # Return a single image from the carousel by index.
    carousel = job_queue.get_carousel()
    if index < 0 or index >= len(carousel): # catch out of bounds
        return Response(status_code=404)

    file = carousel[index]
    await file.seek(0)
    data = await file.read()
    await file.seek(0)

    return StreamingResponse(file, media_type="image/png")  # not sure if png is the format
